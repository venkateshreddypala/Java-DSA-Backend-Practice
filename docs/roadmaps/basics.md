# 📘 Roadmap: Mastering Basic DSA & Implementations (Java)

This roadmap is structured to help you **systematically master basic data structures and algorithms (DSA)** with clear learning goals, coding tasks, and problem sets.

---

## 📍 Phase 1: Foundations
🎯 **Goal**: Understand how data is stored, accessed, and manipulated.

### Topics
- Time & Space Complexity (Big-O, Big-Θ, Big-Ω)
- Recursion Basics

### Implementation Tasks
- Write factorial (recursive & iterative)
- Fibonacci (recursive + memoized)
- GCD using Euclidean Algorithm

✅ **Milestone**: Comfortably analyze time/space trade-offs.

---

## 📍 Phase 2: Arrays & Strings
🎯 **Goal**: Build comfort with contiguous memory & indexing.

### Topics
- Arrays: insertion, deletion, rotation
- Strings: reversal, palindrome, substring search

### Implementation Tasks
- Reverse array in-place
- Rotate array (left/right)
- Implement string reversal & palindrome check
- Count character frequencies

### Problems
- [ ] [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)
- [ ] [14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)
- [ ] [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

✅ **Milestone**: Can implement and manipulate arrays/strings confidently.

---

## 📍 Phase 3: Linked Lists
🎯 **Goal**: Understand dynamic memory & pointer-based structures.

### Topics
- Singly Linked List
- Doubly Linked List
- Fast & Slow Pointer Technique

### Implementation Tasks
- Implement `Node` class & `LinkedList` class
- Insert at head, tail, position
- Delete by value/index
- Reverse linked list
- Detect cycle (Floyd’s cycle detection)

### Problems
- [ ] [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- [ ] [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
- [ ] [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

✅ **Milestone**: Implement full linked list + solve 3–5 LeetCode problems.

---

## 📍 Phase 4: Stacks & Queues
🎯 **Goal**: Apply LIFO/FIFO for problem solving.

### Topics
- Stack (array & linked list)
- Queue (array & linked list)
- Circular Queue
- Deque

### Implementation Tasks
- Implement stack (push, pop, peek)
- Implement queue (enqueue, dequeue)
- Implement circular queue
- Implement min-stack (with auxiliary stack)

### Problems
- [ ] [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
- [ ] [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)
- [ ] [155. Min Stack](https://leetcode.com/problems/min-stack/)

✅ **Milestone**: Comfortable with stack/queue operations & parentheses problems.

---

## 📍 Phase 5: Hashing
🎯 **Goal**: Achieve O(1) average lookups & frequency counting.

### Topics
- Hash Table basics
- HashSet, HashMap in Java

### Implementation Tasks
- Implement hash table (array + linked list for collision handling)
- Use HashMap for frequency counting
- Implement custom hash function for strings

### Problems
- [ ] [1. Two Sum](https://leetcode.com/problems/two-sum/)
- [ ] [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)
- [ ] [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

✅ **Milestone**: Confident in frequency counting & lookup problems.

---

## 📍 Phase 6: Trees
🎯 **Goal**: Understand hierarchical data structures.

### Topics
- Binary Trees
- Binary Search Trees (BST)
- Tree Traversals (Inorder, Preorder, Postorder, Level Order)

### Implementation Tasks
- Build Binary Tree from array
- Insert & search in BST
- Recursive traversals
- Level order traversal (using queue)

### Problems
- [ ] [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)
- [ ] [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
- [ ] [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

✅ **Milestone**: Comfortably traverse and manipulate binary trees.

---

## 📍 Phase 7: Sorting & Searching
🎯 **Goal**: Master searching & sorting fundamentals.

### Topics
- Searching: Linear Search, Binary Search
- Sorting: Bubble, Selection, Insertion, Merge, Quick

### Implementation Tasks
- Implement all basic sorting algorithms
- Implement binary search (iterative + recursive)
- Implement lower/upper bound search

### Problems
- [ ] [704. Binary Search](https://leetcode.com/problems/binary-search/)
- [ ] [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)
- [ ] [912. Sort an Array](https://leetcode.com/problems/sort-an-array/)

✅ **Milestone**: Comfortable coding sorting/searching from scratch.

---

## 📍 Phase 8: Recursion & Backtracking
🎯 **Goal**: Learn systematic exploration of solution space.

### Topics
- Subsets & Permutations
- N-Queens problem
- Rat in a maze

### Implementation Tasks
- Generate all subsets
- Generate permutations
- Solve N-Queens (backtracking)

### Problems
- [ ] [46. Permutations](https://leetcode.com/problems/permutations/)
- [ ] [78. Subsets](https://leetcode.com/problems/subsets/)
- [ ] [51. N-Queens](https://leetcode.com/problems/n-queens/)

✅ **Milestone**: Can apply recursion/backtracking to combinatorial problems.

---

## 📍 Phase 9: Basic Graphs
🎯 **Goal**: Explore connected structures.

### Topics
- Graph representations (Adjacency List, Matrix)
- DFS & BFS
- Connected components

### Implementation Tasks
- Implement graph using adjacency list
- Implement DFS (recursive & iterative)
- Implement BFS (queue)

### Problems
- [ ] [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [ ] [133. Clone Graph](https://leetcode.com/problems/clone-graph/)
- [ ] [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

✅ **Milestone**: Comfortable applying DFS/BFS to grid & graph problems.

---

## 📍 Phase 10: Dynamic Programming (Intro)
🎯 **Goal**: Optimize recursive problems with overlapping subproblems.

### Topics
- Memoization (Top-Down DP)
- Tabulation (Bottom-Up DP)

### Implementation Tasks
- Fibonacci (memoization & tabulation)
- Longest Common Subsequence
- Coin Change (min coins)

### Problems
- [ ] [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
- [ ] [322. Coin Change](https://leetcode.com/problems/coin-change/)
- [ ] [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

✅ **Milestone**: Comfortably identify and solve basic DP problems.

---

## 🎯 Final Integration
By this stage, you should:
- Be able to **implement all basic DS** from scratch in Java.
- Solve **100–150 problems** across arrays, strings, linked lists, stacks, queues, hashing, trees, sorting, recursion, graphs, and DP.
- Apply **pattern recognition** (e.g., two pointers, sliding window, hash map, recursion).

---
